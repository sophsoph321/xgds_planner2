{% extends "base.html" %}

{% block siteSection %}OpenLayers3 Test{% endblock siteSection %}

{% block cssExtras %}
	<link rel="stylesheet" href="{{EXTERNAL_URL}}ol3/css/ol.css" type="text/css">
    <style>
      .map {
        height: 400px;
        width: 100%;
      }
    </style>
{% endblock cssExtras %}

{% block sitemenu-content-secondary %}
{% include "xgds_planner2/planner2_subnav.html" %}
{% endblock %}

{% block content %}
{{ block.super }}
	<h2>My Map</h2>
    <div id="map" class="map"></div>
{% endblock content %}

{% block scripts %}
 {{ block.super }}
 <script src="{{EXTERNAL_URL}}ol3/build/ol-debug.js" type="text/javascript"></script>
{% endblock scripts %}

{% block jsInit %}
  var map = new ol.Map({
    target: 'map',
    layers: [
      new ol.layer.Tile({
        source: new ol.source.MapQuest({layer: 'sat'})
      })
    ],
    view: new ol.View({
      center: ol.proj.transform([37.41, 8.82], 'EPSG:4326', 'EPSG:3857'),
      zoom: 4
    })
  });
  
  // The features are not added to a regular vector layer/source,
// but to a feature overlay which holds a collection of features.
// This collection is passed to the modify and also the draw
// interaction, so that both can add or modify features.
var featureOverlay = new ol.FeatureOverlay({
  style: new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: '#ffcc33',
      width: 2
    }),
    image: new ol.style.Circle({
      radius: 7,
      fill: new ol.style.Fill({
        color: '#ffcc33'
      })
    })
  })
});
featureOverlay.setMap(map);

featureOverlay.getFeatures().on('remove', function(e){
	console.log(e);
});
featureOverlay.getFeatures().on('add', function(e){
	console.log(e);
	e.element.on('change', function(event) {
		console.log(event);
		console.log(this);
	}, e.element);
	e.element.on('remove', function(event) {
		console.log(event);
		console.log(this);
	}, e.element);
});

var modify = new ol.interaction.Modify({
  features: featureOverlay.getFeatures(),
  // the SHIFT key must be pressed to delete vertices, so
  // that new vertices can be drawn at the same position
  // of existing vertices
  deleteCondition: function(event) {
    return ol.events.condition.shiftKeyOnly(event) &&
        ol.events.condition.singleClick(event);
  }
});
map.addInteraction(modify);

var draw = new ol.interaction.Draw({
    features: featureOverlay.getFeatures(),
    type: /** @type {ol.geom.GeometryType} */ ol.interaction.DrawMode.LINE_STRING
  });
  map.addInteraction(draw);
  
   var selectNavigate = new ol.interaction.Select({
                            layers: [this.segmentsLayer, this.stationsLayer],
                            style: (function() {
                                  return function(feature, resolution) {
                                      var model = feature.get('model');
                                      switch (model.get('type')) {
                                      case 'Station':
                                          return [feature.get('selectedStyle'), feature.getStyle()[1]];
                                          break;
                                      case 'Segment':
                                          return [app.styles['selectedSegment']];
                                          break;
                                      }
                                  };
                                })()
                            });
  {% endblock jsInit %}
      
